#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import atexit
from wb_mcu_fw_updater import fw_downloader, update_monitor, user_log, die, fw_flasher, CONFIG, logger
from wb_modbus.bindings import WBModbusDeviceBase, TooOldDeviceError
from wb_modbus.minimalmodbus import ModbusException
from wb_modbus.instruments import StopbitsTolerantInstrument
from wb_modbus import parse_uart_settings_str


def check_internet_connection():
    try:
        fw_downloader.get_request(CONFIG['ROOT_URL'])
    except fw_downloader.WBRemoteStorageError as e:
        die("%s is not accessible. Check Internet connection!" % CONFIG['ROOT_URL'])


def _update_alive_device(slaveid, port, mode, serial_timeout, branch, version, force, erase_settings):
    check_internet_connection()

    try:
        modbus_connection = update_monitor.get_correct_modbus_connection(slaveid, port, serial_timeout=serial_timeout)
    except ModbusException as e:
        logger.error("Check device's connection, slaveid and serial port settings!")
        die(e)

    try:
        update_monitor.flash_alive_device(modbus_connection, mode, branch, version, force, erase_settings)
        logger.info('%s', user_log.colorize('Done', 'GREEN'))
    except (
        TooOldDeviceError,
        ModbusException,
        update_monitor.UpdateDeviceError,
        update_monitor.NoReleasedFwError,
        fw_downloader.WBRemoteStorageError,
        fw_flasher.FlashingError ) as e:
        logger.error("Flashing %s to (%d %s) has failed!", mode, slaveid, port)
        die(e)


def update_fw(args):
    """
    Updating device's firmware.
    Could install specified fw_version from specified branch.
    """
    _update_alive_device(slaveid=args.slaveid, port=args.port, mode='fw', serial_timeout=args.serial_timeout, branch=args.branch_name, version=args.specified_version, force=args.force, erase_settings=args.erase_settings)


def update_bootloader(args):
    """
    Updating device's bootloader.
    Only latest version from stable branch is available.
    """
    _update_alive_device(slaveid=args.slaveid, port=args.port, mode='bootloader', serial_timeout=args.serial_timeout, branch='', version='latest', force=args.force, erase_settings=False)


def recover_fw(args):
    """
    Recovering the device, stuck in the bootloader
    """
    check_internet_connection()

    device_str = "%d %s" % (args.slaveid, args.port)

    if args.slaveid != 0:  # A broadcast-connected device does not answer to in-bootloader-probing cmd
        device = WBModbusDeviceBase(args.slaveid, args.port, instrument=StopbitsTolerantInstrument, serial_timeout=args.serial_timeout)
        if not device.is_in_bootloader():
            die("Device (%s) is not in bootloader mode! Check connection or slaveid/port" % device_str)

    try:
        fw_signatures_list = fw_downloader.get_fw_signatures_list()
        args.known_signature = args.known_signature or update_monitor._restore_fw_signature(args.slaveid, args.port, serial_timeout=args.serial_timeout)

        if args.known_signature:
            update_monitor.recover_device_iteration(args.known_signature, args.slaveid, args.port, in_bl_serial_timeout=args.serial_timeout)

        elif update_monitor.ask_user('Try all possible fw_signatures (%s) for (%s); serial_timeout: %.2f?' % (', '.join(fw_signatures_list), device_str, args.serial_timeout)):
            for fw_sig in fw_signatures_list:
                logger.info('Trying %s:', fw_sig)
                try:
                    update_monitor.recover_device_iteration(fw_sig, args.slaveid, args.port, in_bl_serial_timeout=args.serial_timeout)
                    break
                except fw_flasher.FlashingError:
                    continue
            else:
                raise fw_flasher.FlashingError("No fw_signature from all possible has succeed for device (%s)" % device_str)
        else:
            raise update_monitor.UserCancelledError("Trying all possible fw_signatures has rejected by user")

        logger.info('%s (%s)', user_log.colorize('Done', 'GREEN'), device_str)

    except (
        fw_downloader.WBRemoteStorageError,
        fw_flasher.FlashingError,
        update_monitor.NoReleasedFwError,
        update_monitor.UserCancelledError
    ) as e:
        logger.error("Recovering (%d %s) was not successful" % (args.slaveid, args.port))
        die(e)


def update_all(args):
    """
    Updating firmwares for all devices, specified in wb-mqtt-serial's config.
    """
    check_internet_connection()
    try:
        update_monitor._update_all(force=args.force, allow_downgrade=args.allow_downgrade)
    except update_monitor.ConfigParsingError as e:
        die(e)


def recover_all(args):
    """
    Trying to recover all devices, specified in wb-mqtt-serial's config.
    """
    check_internet_connection()
    try:
        update_monitor._recover_all()
    except update_monitor.ConfigParsingError as e:
        die(e)


def flash_fw_file(args):
    """
    Directly flashing a fw-file (passed as arg) (args are almost compatible to wb-mcu-fw-flasher)
    """
    device_str = "%s %d %s" % (args.port, args.slaveid, str(args.conn_settings))

    if args.jump_in_bl:
        _device = WBModbusDeviceBase(args.slaveid, args.port, *args.conn_settings, serial_timeout=args.serial_timeout)
        try:
            _device.reboot_to_bootloader()
        except ModbusException as e:
            die("Device (%s) could not reboot to bootloader. Check connection params" % device_str)

    try:
        update_monitor.direct_flash(args.fname, args.slaveid, args.port, args.erase_all, args.erase_uart, serial_timeout=args.serial_timeout)
        return
    except fw_flasher.NotInBootloaderError as e:
        logger.error("Seems, device (%s) is not in bootloader now!", device_str)
        logger.error("Try again with '-j' arg")
    except (fw_flasher.FlashingError, update_monitor.UserCancelledError) as e:
        logger.exception(e)
    logger.error("Unsuccessful flashing!")
    logger.error("\tDevice: %s FW: %s", device_str, args.fname)
    die()


def parse_conn_settings_arg(conn_settings_str):
    try:
        return parse_uart_settings_str(conn_settings_str)
    except Exception as e:
        logger.error(e)
        die()


def parse_args():
    main_parser = argparse.ArgumentParser(prog='wb-mcu-fw-updater', formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                          description='Wiren Board modbus devices firmware/bootloader update tool.', add_help=True)
    main_parser.add_argument('--debug', dest='user_loglevel', default=None, action='store_const',
                             const=10, help='Setting the least loglevel. (Default: %(default)s)')
    subparsers = main_parser.add_subparsers(
        title='Actions', help='Choose mode:\n')

    """
    Updating firmware on single working device.
    """
    update_fw_parser = subparsers.add_parser(
        'update-fw', help='Update firmware on single working device.')
    update_fw_parser.add_argument('--branch', type=str, dest='branch_name', metavar='<branch_name>', default='',
                                  help='Install firmware from specified branch. (Default: %(default)s)')
    update_fw_parser.add_argument('--version', type=str, dest='specified_version', metavar='<fw_version>',
                                  default='release', help='Download a specified firmware version. (Default: %(default)s)')
    update_fw_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings',
                                  default=False, help="Erase all device's settings during update. (Default: %(default)s)")
    update_fw_parser.add_argument('-f', '--force', action='store_true', dest='force', default=False,
                                  help='Perform force device reflash, even if firmware is latest. (Default: %(default)s)')
    update_fw_parser.add_argument('-T', '--serial-timeout', type=float, dest='serial_timeout', metavar='<serial_timeout>', default=0.2,
                                  help='Serial_timeout to communicate with device. (Default: %(default)s)')
    update_fw_parser.add_argument(
        '-a', '--slaveid', type=int, dest='slaveid', metavar='<slaveid>', required=True, choices=range(1, 247), help='Slave address of the device.')
    update_fw_parser.add_argument(
        "port", type=str, metavar='<port>', help='Serial port, device connected to.')
    update_fw_parser.set_defaults(func=update_fw)

    """
    Updating bootloader on single working device.
    """
    update_bootloader_parser = subparsers.add_parser(
        'update-bl', help='Update bootloader on single working device.')
    update_bootloader_parser.add_argument('-f', '--force', action='store_true', dest='force', default=False,
                                          help='Perform force device reflash, even if firmware is latest. (Default: %(default)s)')
    update_bootloader_parser.add_argument(
        '-a', '--slaveid', type=int, metavar='<slaveid>', dest='slaveid', required=True, choices=range(1, 247), help='Slave address of the device.')
    update_bootloader_parser.add_argument(
        '-T', '--serial-timeout', type=float, dest='serial_timeout', metavar='<serial_timeout>', default=0.2,
        help='Serial_timeout to communicate with device. (Default: %(default)s)')
    update_bootloader_parser.add_argument(
        "port", type=str, metavar='<port>', help='Serial port, device connected to.')
    update_bootloader_parser.set_defaults(func=update_bootloader)

    """
    Flash single device, stuck in the bootloader.
    """
    recover_fw_parser = subparsers.add_parser(
        'recover', help="Restore the latest firmware on stuck in bootloader device.")
    recover_fw_parser.add_argument('--fw-sig', dest='known_signature', type=str, metavar='<fw_signature>', default=None,
                                   help="Force specify device's firmware signature. (Default: %(default)s)")
    recover_fw_parser.add_argument('--restore-defaults', action='store_true', dest='erase_settings',
                                   default=False, help="Erase all device's settings during flashing. (Default: %(default)s)")
    recover_fw_parser.add_argument('-T', '--serial-timeout', type=float, dest='serial_timeout', metavar='<serial_timeout>', default=0.2,
                                  help='Serial_timeout to communicate with device. (Default: %(default)s)')
    recover_fw_parser.add_argument(
        '-a', '--slaveid', type=int, dest='slaveid', metavar='<slaveid>', required=True, help='Slave address of the device.')
    recover_fw_parser.add_argument(
        "port", type=str, metavar='<port>', help='Serial port, device connected to.')
    recover_fw_parser.set_defaults(func=recover_fw)

    """
    Update firmware on all devices, found in wb-mqtt-serial config.
    """
    update_all_fw_parser = subparsers.add_parser(
        'update-all', help="Trying to update firmwares on all devices, added to wb-mqtt-serial's config.")
    update_all_fw_parser.add_argument('-f', '--force', action='store_true', dest='force', default=False,
                                    help='Perform force updates of all devices, even if firmwares are latest. (Default: %(default)s)')
    update_all_fw_parser.add_argument('--allow-downgrade', action='store_true', dest='allow_downgrade', default=False,
                                    help='Firmware versions could be downgraded. (Default: %(default)s)')
    update_all_fw_parser.set_defaults(func=update_all)

    """
    Recover firmware on all devices, found in wb-mqtt-serial config (and are actually in bootloader).
    """
    recover_all_parser = subparsers.add_parser(
        'recover-all', help="Trying to recover all devices, added to wb-mqtt-serial's config.")
    recover_all_parser.set_defaults(func=recover_all)

    """
    Flash a FW file to single device.
    """
    direct_flash_parser = subparsers.add_parser(
        'flash-file', help="Directly flash firmware file")
    direct_flash_parser.add_argument(
        "port", type=str, metavar='<serial_port>')
    direct_flash_parser.add_argument(
        '-a', '--slaveid', type=int, dest='slaveid', metavar='<slaveid>', required=True, help='Slave address of the device')
    direct_flash_parser.add_argument(
        '-T', '--serial-timeout', type=float, dest='serial_timeout', metavar='<serial_timeout>', default=0.2,
        help='Serial_timeout to communicate with device. (Default: %(default)s)')
    direct_flash_parser.add_argument(
        '--conn-settings', type=parse_conn_settings_arg, dest='conn_settings', metavar='<connection_settings_str>', default='9600N2', help="Connection settings to communicate with alive device (Default: %(default)s)")
    direct_flash_parser.add_argument(
        '-j', action='store_true', dest='jump_in_bl', default=False, help='Jump to bootloader? (use on alive devices; default: %(default)s)')
    direct_flash_parser.add_argument(
        '-u', '--erase-uart', action='store_true', dest='erase_uart', default=False, help="Erase device's uart settings? (Default: %(default)s)")
    direct_flash_parser.add_argument(
        '-e', '--erase-all', action='store_true', dest='erase_all', default=False, help="Erase ALL device's uart settings? (Default: %(default)s)")
    direct_flash_parser.add_argument(
        '-f', type=str, dest='fname', metavar='<firmware_file>', required=True, help='File to flash')
    direct_flash_parser.set_defaults(func=flash_fw_file)

    args = main_parser.parse_args()
    if 'func' in vars(args):
        return args
    else:
        main_parser.print_help()
        print("Each action supports <-h> key for help.")
        die('No action has chosen!')


if __name__ == "__main__":
    args = parse_args()

    user_log.setup_syslog_logger("wb_mcu_fw_updater")
    user_loglevel = args.user_loglevel or CONFIG['USER_LOGLEVEL']
    user_log.setup_user_logger("wb_mcu_fw_updater", user_loglevel)
    user_log.setup_user_logger("wb_modbus", user_loglevel)

    update_monitor.pause_driver()
    atexit.register(update_monitor.resume_driver)
    atexit.register(update_monitor.db.dump)

    update_monitor.fill_release_info()

    if 'port' in vars(args):
        initial_port_settings = update_monitor.get_port_settings(args.port)
        atexit.register(lambda: update_monitor.set_port_settings(args.port, initial_port_settings))

    args.func(args)
